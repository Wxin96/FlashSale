# 秒杀项目整理

## 零、返回结果封装/异常拦截

### 0.1 结果封装

#### 0.1.1 封装结果类

> 类CodeMsg主要包含两个信息，
>
> - 代码
> - 消息
>
> 定义消息静态属性，定义错误信息。
>
> 类都是私有构造器。

```java
package com.apollo.flashsale.result;

import lombok.Getter;

@Getter
public class CodeMsg {
    // 代码
    private int code;
    // 信息
    private String msg;
    private CodeMsg(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    // 通用异常
    public static final CodeMsg SUCCESS = new CodeMsg(0, "success");
    public static final CodeMsg SERVER_ERROR = new CodeMsg(5001000, "服务器异常");
    public static final CodeMsg BIND_ERROR = new CodeMsg(500101, "参数校验异常,%s");
    public static final CodeMsg REQUEST_ILLEGAL_VERIFY_CODE = new CodeMsg(500102, "图片验证码输入错误!");
    public static final CodeMsg REQUEST_ILLEGAL = new CodeMsg(500103, "请求非法");
    public static final CodeMsg ACCESS_LIMIT_REACHED = new CodeMsg(500104, "访问太频繁");
    //登录模块 5002XX
    public static final CodeMsg SESSION_ERROR = new CodeMsg(500210, "Session不存在或者已经失效");
    public static final CodeMsg PASSWORD_EMPTY = new CodeMsg(500211, "登陆密码不能为空");
    public static final CodeMsg MOBILE_EMPTY = new CodeMsg(500212, "手机号不能为空");
    public static final CodeMsg MOBILE_ERROR = new CodeMsg(500213, "手机号格式错误");
    public static final CodeMsg MOBILE_NOT_EXIST = new CodeMsg(500214, "手机号不存在");
    public static final CodeMsg PASSWORD_ERROR = new CodeMsg(500215, "密码错误");
    //商品模块 5003XX

    //订单模块 5004XX
    public static final CodeMsg ORDER_NOT_EXIST = new CodeMsg(500400, "订单不存在");

    //秒杀模块 5005XX
    public static final CodeMsg FLASH_SALE_OVER = new CodeMsg(500500, "商品已经秒杀完毕");
    public static final CodeMsg REPEAT_FLASH_SALE = new CodeMsg(500501, "不能重复秒杀");
    public static final CodeMsg FLASH_SALE_FAIL = new CodeMsg(500502, "秒杀失败");

    // 自定义异常
    public CodeMsg fillArgs(Object... args) {
        int code = this.code;
        String message = String.format(this.msg, args);
        return new CodeMsg(code, message);
    }
}
```

#### 0.1.2 外层封装类

> 简单理解，CodeMsg + T data
>
> 类的特点：
>
> 1. 都是私有构造器
> 2. 两个静态方法输入 `CodeMSg` 

```java
package com.apollo.flashsale.result;

import lombok.Getter;

@Getter
public class Result<T> {
    private int code;
    private String msg;
    private T data;

    // 默认成功构造器
    private Result(T data) {
        this.code = 0;
        this.msg = "success";
        this.data = data;
    }

    // 失败构造器
    private Result(CodeMsg codeMsg) {
        // 避免空指针异常
        if (codeMsg == null) {
            return;
        }
        this.code = codeMsg.getCode();
        this.msg = codeMsg.getMsg();
    }

    /**
     * 成功时, 调用
     * @param data 数据
     * @param <T> data的泛型
     * @return 结果信息封装
     */
    public static <T> Result<T> success(T data) {
        return new Result<>(data);
    }

    /**
     * 失败时, 调用
     * @param codeMsg 错误类型
     * @param <T>   数据泛型
     * @return  结果信息封装
     */
    public static <T> Result<T> error(CodeMsg codeMsg) {
        return new Result<>(codeMsg);
    }

}
```

#### 0.1.3 异常

> `GlocalException`类继承`RuntimeException`
>
> 将 CodeMsg 的 `codeMsg.toString()` 传入 异常的detailMessage中.

```java
package com.apollo.flashsale.exception;

import com.apollo.flashsale.result.CodeMsg;

public class GlobalException extends RuntimeException {

    private static final long serialVersionUID = 1L;
	// 属性
    private CodeMsg codeMsg;

    public GlobalException(CodeMsg codeMsg) {
        super(codeMsg.toString());
        this.codeMsg = codeMsg;
    }

    public CodeMsg getCodeMsg() {
        return codeMsg;
    }
}
```

#### 0.1.4 异常拦截器

> 异常处理三种类型:
>
> - 抛出的`GlobalException`, 含有CodeMsg字段信息
> - 抛出的的`BindException`, 
> - 抛出的其他异常
>
> 封装进 `Result`类, 抛出json格式

```java
/**
 *  异常处理类
 */
@Slf4j
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public Result<String> exceptionHandler(HttpServletRequest request, Exception e) {
        // e.printStackTrace();
        log.error("出现异常", e);
        if (e instanceof GlobalException) {
            GlobalException ex = (GlobalException) e;
            log.error(ex.getCodeMsg().getMsg());
            return Result.error(ex.getCodeMsg());
        } else if (e instanceof BindException) {
            BindException ex = (BindException) e;
            List<ObjectError> errors = ex.getAllErrors();
            ObjectError error = errors.get(0);
            String message = error.getDefaultMessage();
            CodeMsg bindError = CodeMsg.BIND_ERROR.fillArgs(message);
            log.error(bindError.getMsg());
            return Result.error(bindError);
        } else {
            CodeMsg serverError = CodeMsg.SERVER_ERROR;
            log.error(serverError.getMsg());
            return Result.error(serverError);
        }
    }

}
```



## 一、登录功能

### 1.1 MD5 + Salt 加密

> 参考:https://juejin.im/post/6844903604944371726
>
> https://www.zhihu.com/question/20299384
>
> 大体思路, 通过客户端一层对密码MD5加盐, 数据库一端, 对密码进行第二次MD5加盐, 保证密码安全性.

#### 1.1.1 在 `login.html` 页面

> 哈希算法(单向加密算法), MD5, SHA;
>
> 攻击: 彩虹表
>
> 防御: 加salt

客户端, MD5(inputPassword + salt), 传输加密密码

**问题:** 客户端加盐, 代码可见

**解决:**动态申请Salt

**问题:**短盐和盐的复用,

**解决**: 动态生成 salt, **用户每次创建或者修改密码一定要使用一个新的随机的盐**

#### 1.1.2 服务器端&数据库

服务器端, MD5(formPassword + salt) 与数据库密码验证;(就算数据库数据泄露,用户密码不会泄露)

### 1.2 JSR303校验

> springboot参数校验。
>
> 项目 `validator` 关于参数验证。
>
> 大体思想，验证`LoginVo`类中加注解参数, 并且自定义了一个 `@Mobile`注解配和`IsMobileValidor`类验证手机号的格式.

登录方法：

> 1. @Valid 注解，标记属性、方法参数或方法返回类型以进行验证级联。
> 2. 使用 JSR303 校验框架，自定义 `@IsMobile` 注解 和`IsMobileValidator` 校验类

```java
@RequestMapping("/do_login")
@ResponseBody
public Result<String> doLogin(HttpServletResponse response, @Valid LoginVo loginVo) {
    logger.trace("用户登录提交信息:" + loginVo.toString());
    // 登录(如果有异常会走异常拦截的线)
    String token = flashSaleUserService.login(response, loginVo);
    // 判断
    return Result.success(token);
}
```

### 1.3 token加密算法 实现 ~~单点登录（Single Sign On，SSO）~~

> 其他方式：JWT（JSON Web Token）方式。
>
> HttpOnly属性

**实现方式：**

 登录成功后，服务器端根据 UUID 生成标识，分布式缓存存入Redis中，添加cookie（token：uuid）存入客户端。

**存在的问题：**

1. 有 CSRF 漏洞。
2. http明文传输，https加密
3. 无法识别token是否是伪造的

### 1.4 根据token获取用户

> AccessInterceptor拦截器类中gerUser方法, 获取到用户会延长cookie和redis键值的有效期

```java
/**
 *  根据请求request和响应response获取秒杀用户信息
 * @param request 请求
 * @param response 响应
 * @return 秒杀用户
 */
private FlashSaleUser gerUser(HttpServletRequest request, HttpServletResponse response) {
    // 1.从参数或者Cookie中获取 token(uuid)
    String paramToken = request.getParameter(FlashSaleUserService.COOKIE_NAME_TOKEN);
    String cookieToken = getCookieValue(request, FlashSaleUserService.COOKIE_NAME_TOKEN);
    log.debug("请求参数中paramToken:" + paramToken);
    log.debug("Cookie中cookieToken:" + cookieToken);
    // 2.根据这两个参数, 确定优先级获取FlashSaleUser
    if (StringUtils.isEmpty(paramToken) && StringUtils.isEmpty(cookieToken)) {
        log.debug("Cookie和请求参数中均没有token的值!");
        return null;
    }
    String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;
    log.debug("Cookie标识token:" + token);
    return userService.getByToken(response, token);
}
```

### 1.5 ThreadLocal中存储FlashSaleUser用户

> 流程:
>
> 1. `AccessInterceptor`拦截器中获取用户类, 存入`ThreadLocal`中
> 2. 在`FlashSaleUserArgumentResolver`类中取出用户

```java
UserContext.setUser(user);
/**
 *  线程局部存储秒杀用户
 */
public class UserContext {

    private static ThreadLocal<FlashSaleUser> userHolder = new ThreadLocal<>();

    public static FlashSaleUser getUser() {
        return userHolder.get();
    }

    public static void setUser(FlashSaleUser user) {
        userHolder.set(user);
    }
}
```

**自定义参数解析器`FlashSaleUserArgumentResolver`, `WebConfig`注入容器**

```java
@Override
public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
                              NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
    logger.trace("解析FlashSaleUser用户~");
    // 1.从线程中获取
    FlashSaleUser user = UserContext.getUser();
    // 2.判断是否为空
    if (user == null) {
        logger.warn("解析用户为空!");
    }
    return user;
}
```

### 1.6 用户登陆限制 防止恶意刷接口

> 通过拦截器`AccessInterceptor`+ 注解`AccessLimit`实现, `WebConfig`注入容器

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 判断是不是方法上的注解
    if (handler instanceof HandlerMethod) {
        // 1.根据请求获取用户, 并保存在ThreadLocal中
        FlashSaleUser user =  gerUser(request, response);
        UserContext.setUser(user);
        // 2.使用handler获取注解的值
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        AccessLimit accessLimit = handlerMethod.getMethodAnnotation(AccessLimit.class);
        // 3.判断注解是否为空, 为空放行
        if (accessLimit == null) {
            return true;
        }
        // 4.获取注解的值
        int seconds = accessLimit.seconds();
        int maxCount = accessLimit.maxCount();
        boolean needLogin = accessLimit.needLogin();
        // 5.根据是否需要登录执行不同的命令
        String userLoginLimit = request.getRequestURI();
        if (needLogin) {
            if (user == null) {
                // 利用response传递
                render(response, CodeMsg.SESSION_ERROR);
                return false;
            } else {
                userLoginLimit += "_" + user.getId();
            }
        } else {
            // do nothing
            return true;
        }
       // 6.利用Redis缓存设置登录限制
        AccessKey accessKey = AccessKey.withExpire(seconds);
        Integer count = redisService.get(accessKey, userLoginLimit, Integer.class);
        if(count  == null) {
            log.trace("用户" + user.getId() + "第一次登陆~");
            redisService.set(accessKey, userLoginLimit, 1);
        }else if(count < maxCount) {
            Long incr = redisService.incr(accessKey, userLoginLimit);
            log.trace("用户" + user.getId() + "第" + incr + "次登陆");
        }else {
            log.warn("用户" + user.getId() + "登录次数频繁, 超出限制");
            render(response, CodeMsg.ACCESS_LIMIT_REACHED);
            return false;
        }
    }
    return true;
}
/**
 * 利用response响应发送数据
 * @param response 响应
 * @param codeMsg 通过响应response发送的消息
 * @throws Exception
 */
private void render(HttpServletResponse response, CodeMsg codeMsg) throws Exception {
    response.setContentType("application/json;charset=UTF-8");
    OutputStream outputStream = response.getOutputStream();
    String responseBody = JSON.toJSONString(Result.error(codeMsg));
    outputStream.write(responseBody.getBytes(StandardCharsets.UTF_8));
    outputStream.flush();
    outputStream.close();
}
```

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface AccessLimit {

    /**
     *  定义访问时长, 单位:s
     * @return 访问时长
     */
    int seconds();

    /**
     *  定义访问时长中, 最大访问次数
     * @return 访问时长中的最大访问次数
     */
    int maxCount();

    /**
     *  是否需要登录, 默认值为需要(true)
     * @return true(默认), 需要; false, 不需要.
     */
    boolean needLogin() default true;
}
```





## 二、Redis配置

### 2.1 Redis的Key，模板设计模式

#### 2.1.1 `Key`接口

```java
/**
 *  前缀接口
 */
public interface KeyPrefix {
    // 过期时间，设置TTL过期时间
    int expireSeconds();
    // 前缀, 用于标识
    String getPrefix();

}
```

#### 2.1.2 抽象类

```java
public abstract class BasePrefix implements KeyPrefix {
    
    private int expireSeconds;
	// 自定义前缀部分
    // 真正前缀由class.getSimpleName() + : + prefix 组成 
    private String prefix;

    // 0代表永不过期, 永不过期方法
    public BasePrefix(String prefix) {
        this(0, prefix);
    }

    public BasePrefix(int expireSeconds, String prefix) {
        this.expireSeconds = expireSeconds;
        this.prefix = prefix;
    }

    @Override
    public int expireSeconds() {
        return expireSeconds;
    }

    /**
     * 根据类名, 组合前缀
     * @return
     */
    @Override
    public String getPrefix() {
        String className = this.getClass().getSimpleName();
        return className + ":" + prefix;
    }
}
```

#### 2.1.3 类

> 拿 `FlashSaleUserKey`  举例
>
> 1. 自定义了 token 的有效期
> 2. 重写 两个变量的构造方法
> 3. 生成静态变量 供使用

```java
/**
 *  作用: 存储FlashSale用户信息
 *  细节:
 *      有效期 两天
 */
public class FlashSaleUserKey extends BasePrefix {

    // 两天
    public static final int TOKEN_EXPIRE = 3600 * 24 * 20;
    // public static final int TOKEN_EXPIRE = 0;

    public FlashSaleUserKey(int expireSeconds, String prefix) {
        super(expireSeconds, prefix);
    }

    // 分布式Session, 利用Cookie查询用户登录
    public static FlashSaleUserKey token = new FlashSaleUserKey(TOKEN_EXPIRE, "tk");

    // 用户信息缓存, 永久有效
    public static FlashSaleUserKey getById = new FlashSaleUserKey(0, "id");

}
```

### 2.2 Redis配置

#### 2.2.1 Redis属性类

```java
@Setter
@Getter
@ConfigurationProperties(prefix = "redis")
public class RedisProperties {
    // Redis主机
    private String host;
    // Redis端口号
    private int port;

    private int timeout;//秒
    // 密码
    private String password;
    // 最大连接数量
    private int poolMaxTotal;
    // 连接池最多空闲数目
    private int poolMaxIdle;
    // 连接池最大等待时间
    private int poolMaxWait;//秒
}

```

#### 2.2.2 Redis注入

```java
@Configuration
@EnableConfigurationProperties(RedisProperties.class)
public class RedisConfig {

    @Autowired
    RedisProperties redisProperties;

    @Bean
    public JedisPool JedisPoolFactory() {
        // 1.JedisPoolConfig JedisPool的配置类
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxIdle(redisProperties.getPoolMaxIdle());
        config.setMaxTotal(redisProperties.getPoolMaxTotal());
        config.setMaxWaitMillis(redisProperties.getPoolMaxWait());
        // 2.注册JedisPool
        // 参数中的timeout需要毫秒
        JedisPool jedisPool = new JedisPool(config, redisProperties.getHost(), redisProperties.getPort(),
                redisProperties.getTimeout()*1000, redisProperties.getPassword(), 0);
        return jedisPool;
    }

}
```

### 2.3 Redis服务层

> 常规方法:
>
> > 真正的key由两部分组成，KeyPrefix前缀（类别）和用户自定义key（个体区分）
>
> - get
> - set
> - delete
> - exists
> - incr
> - decr
>
> 类和字符串之间转换
>
> > POJO <=> JSON 使用的是 alibaba的fastjson
>
> - stringToBean
> - beanToString
>
> 连接返回Jedis池中
>
> - returnToPool
>
> 

```java
@Service
public class RedisService {

    @Autowired
    JedisPool jedisPool;

    /**
     * 获取单个对象
     *
     * @param prefix 前缀
     * @param key    id
     * @param clazz  实体类型字节码
     * @param <T>    实体类型泛型
     * @return
     */
    public <T> T get(KeyPrefix prefix, String key, Class<T> clazz) {
        Jedis jedis = null;
        try {
            // 1.获取链接
            jedis = jedisPool.getResource();
            // 2.生成真正的key
            String realKey = prefix.getPrefix() + key;
            String str = jedis.get(realKey);
            T t = stringToBean(str, clazz);
            return t;
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 设置对象
     *
     * @param prefix 前缀
     * @param key    id
     * @param value  封装对象
     * @param <T>    封装对象泛型
     * @return 成功返回true
     */
    public <T> boolean set(KeyPrefix prefix, String key, T value) {
        Jedis jedis = null;
        try {
            // 1.获取链接
            jedis = jedisPool.getResource();
            // 2.生成真正的key
            String realKey = prefix.getPrefix() + key;
            // 3.POJO转JSON字符串
            String strValue = beanToString(value);
            // 4.获取保存时间
            int expireSeconds = prefix.expireSeconds();
            // 永不过期
            if (expireSeconds <= 0) {
                jedis.set(realKey, strValue);
            } else {
                // 设置过期时间
                jedis.setex(realKey, expireSeconds, strValue);
            }
            return true;
        } finally {
            returnToPool(jedis);
        }
    }

    public boolean delete(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            // 1.获取链接
            jedis = jedisPool.getResource();
            // 2.生成真正的key
            String realKey = prefix.getPrefix() + key;
            // 3.删除
            Long del = jedis.del(realKey);

            return del > 0;
        } finally {
            returnToPool(jedis);
        }
    }

    public boolean delete(KeyPrefix prefix) {
        // 0.预处理
        if (prefix == null) {
            return false;
        }
        // 1.获取相关key
        List<String> keys = scanKeys(prefix.getPrefix());
        if (keys == null || keys.size() <= 0) {
            return true;
        }
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            jedis.del(keys.toArray(new String[0]));
            return true;
        } catch (final Exception e) {
            e.printStackTrace();
            return false;
        } finally {
            returnToPool(jedis);
        }

    }

    public List<String> scanKeys(String key) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            List<String> keys = new ArrayList<>();
            String cursor = "0";
            ScanParams sp = new ScanParams();
            sp.match("*" + key + "*");
            sp.count(100);
            do {
                ScanResult<String> ret = jedis.scan(cursor, sp);
                List<String> result = ret.getResult();
                if (result != null && result.size() > 0) {
                    keys.addAll(result);
                }
                //再处理cursor
                cursor = ret.getCursor();
            } while (!cursor.equals("0"));
            return keys;
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 判断key是否存在
     *
     * @param prefix 前缀
     * @param key    id
     * @return 存在返回true, 不存在返回false
     */
    public boolean exists(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            // 1.获取链接
            jedis = jedisPool.getResource();
            // 2.生成真正的key
            String realKey = prefix.getPrefix() + key;
            // 3.判断是否村子啊
            return jedis.exists(realKey);
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 增加值
     *
     * @param prefix 前缀
     * @param key    id
     * @return 增加后的数值
     */
    public <T> Long incr(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            // 1.获取链接
            jedis = jedisPool.getResource();
            // 2.生成真正的key
            String realKey = prefix.getPrefix() + key;
            // 3.判断是否村子啊
            return jedis.incr(realKey);
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 减小值
     *
     * @param prefix 前缀
     * @param key    id
     * @return 减小后的数值
     */
    public <T> Long decr(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            // 1.获取链接
            jedis = jedisPool.getResource();
            // 2.生成真正的key
            String realKey = prefix.getPrefix() + key;
            // 3.判断是否村子啊
            return jedis.decr(realKey);
        } finally {
            returnToPool(jedis);
        }
    }


    /**
     * JSON字符串转换为实体类对象
     * 修改一次: 改成 静态 共有方法 便于MQ使用
     *
     * @param str   JSON字符串
     * @param clazz 要转化类的字节码
     * @param <T>   要转化类的泛型
     * @return 返回实体类对象
     */
    @SuppressWarnings("unchecked")
    public static <T> T stringToBean(String str, Class<T> clazz) {
        // 0.预处理
        if (str == null || str.length() <= 0 || clazz == null) {
            return null;
        }
        // 1.分类处理
        if (clazz == int.class || clazz == Integer.class) {
            return (T) Integer.valueOf(str);
        } else if (clazz == String.class) {
            return (T) str;
        } else if (clazz == long.class || clazz == Long.class) {
            return (T) Long.valueOf(str);
        } else {
            // POJO类型
            return JSON.toJavaObject(JSON.parseObject(str), clazz);
        }
    }

    /**
     * 实体类对象转化为字符串
     * 修改一次: 改成 静态 共有方法 便于MQ使用
     *
     * @param value 实体类对象
     * @param <T>   实体类对象泛型
     * @return JSON字符串
     */
    public static <T> String beanToString(T value) {
        // 0.预处理
        if (value == null) {
            return null;
        }
        // 1.分类处理
        Class<?> clazz = value.getClass();
        if (clazz == Integer.class) {
            return "" + value;
        } else if (clazz == String.class) {
            return (String) value;
        } else if (clazz == Long.class) {
            return "" + value;
        } else {
            // POJO类型
            return JSON.toJSONString(value);
        }
    }

    /**
     * 将Jedis连接返回JedisPool中
     *
     * @param jedis 单个jedis连接
     */
    private void returnToPool(Jedis jedis) {
        if (jedis != null) {
            jedis.close();
        }
    }

}
```

## 三、数据库表的设计

### 3.1 flashsale_user表

**字段**

- id
- nickname
- password
- salt
- head(头像,云存储的id)
- register_data
- last_login_date
- login_count

### 3.2 goods表

**字段:**

- id
- goods_name
- goods_titile
- goods_img(路径)
- goods_detail(商品详细)
- goods_price(商品原价)
- goods_stock(商品库存)

### 3.3 order_info订单信息

**字段:**

- id
- user_id
- goods_id
- delivery_add_id
- goods_name
- goods_count
- goods_price
- order_channel
- status
- create_date
- pay_date

### 3.4 flash_sale_goods秒杀商品信息

**字段名:**

- id
- goods_id
- flash_sale_price
- stock_count
- start_data
- end_date

### 3.5 flash_sale_order秒杀订单

> 其中,  UNIQUE KEY `u_uid_gid` (`user_id`,`goods_id`),  **唯一约束**

**字段名:**

- id
- user_id
- goog_id
- order_id

### 3.6 FlashSaleUserDao

> 1. 根据用户查询FlashSaleUser
> 2. 更改密码

```java
@Mapper
public interface FlashSaleUserDao {

    @Select("select * from flashsale_user where id = #{id}")
    FlashSaleUser getById(@Param("id") long id);


    @Update("update flashsale_user set password = #{password} where id = #{id}")
    void updatePassword(FlashSaleUser user);

}
```

### 3.7 GoodsDao

> GoodsDao类混合了goods表和flash_sale_goods表联合
>
> 1. 查找所有的秒杀商品信息
> 2. 获取单个秒杀商品信息
> 3. 秒杀商品减库存
> 4. 秒杀商品库存重置

```java
@Mapper
public interface GoodsDao {
    /**
     *  获取秒杀商品信息
     * @return 秒杀商品列表
     */
    @Select("select g.*, fsg.stock_count, fsg.start_date, fsg.end_date, fsg.flash_sale_price from flash_sale_goods fsg left join goods g on fsg.goods_id = g.id")
    List<GoodsVo> listGoodsVo();

    /**
     *  根据物品id返回特定的秒杀商品
     * @param goodsId 物品id
     * @return 秒杀商品信息
     */
    @Select("select g.*, fsg.stock_count, fsg.start_date, fsg.end_date, fsg.flash_sale_price from flash_sale_goods fsg left join goods g on fsg.goods_id = g.id where g.id = #{goodsId}")
    GoodsVo getGoodsVoByGoodsId(@Param("goodsId") long goodsId);

    /**
     *  秒杀商品减库存
     * @param flashSaleGoods 对应的秒杀商品
     * @return 返回更改的行数
     */
    @Update("update flash_sale_goods set stock_count = stock_count - 1 where goods_Id = #{goodsId} and stock_count > 0")
    int reduceStock(FlashSaleGoods flashSaleGoods);

    /**
     *  秒杀商品库存重置
     * @param g 对应的秒杀商品
     * @return 返回更改的行数
     */
    @Update("update flash_sale_goods set stock_count = #{stockCount} where goods_id = #{goodsId}")
    int resetStock(FlashSaleGoods g);
}
```

### 3.8 OrderDao

> 功能:
>
> - 查询秒杀订单[未使用]
> - 插入新的订单,并返回id
> - 插入秒杀订单[未使用]
> - 根据 id 返回订单信息
> - 删除订单表内容
> - 删除秒杀订单内容

```java
@Mapper
public interface OrderDao {

    @Select("select * from flash_sale_order where user_id = #{userId} and goods_id = #{goodsId}")
    FlashSaleOrder getFlashSaleOrderByUserIdGoodsId(@Param("userId") long userId, @Param("goodsId") long goodsId);

    /**
     *  插入订单信息
     * @param orderInfo 订单信息
     * @return  [改变行数]
     */
    @Insert("insert into order_info(user_id, goods_id, delivery_add_id, goods_name, goods_count, goods_price, order_channel, status, create_date, pay_date)" +
            "values(#{userId}, #{goodsId}, #{deliveryAddrId}, #{goodsName}, #{goodsCount}, #{goodsPrice}, #{orderChannel}, #{status}, #{createDate}, #{payDate})")
    @SelectKey(keyColumn = "id", keyProperty = "id", resultType = long.class, before = false, statement = "select last_insert_id();")
    long insert(OrderInfo orderInfo);

    @Insert("insert into flash_sale_order(user_id, order_id, goods_id) values(#{userId}, #{orderId}, #{goodsId});")
    int insertFlashSaleOrder(FlashSaleOrder flashSaleOrder);

    @Select("select * from order_info where id = #{orderId}")
    OrderInfo getOrderById(@Param("orderId") long orderId);

    @Delete("delete from order_info")
    int deleteOrders();

    @Delete("delete from flash_sale_order")
    int deleteFlashSaleOrders();
}
```

## 四 页面 缓存 和 静态化

### 4.1 页面缓存

> 秒杀商品清单页面默认展示缓存60s, 存入Redis
>
> 自定义渲染.

```java
@Slf4j
@Controller
@RequestMapping("/goods")
public class GoodsController {

    @Autowired
    FlashSaleUserService flashSaleUserService;

    @Autowired
    RedisService redisService;

    @Autowired
    GoodsService goodsService;

    @Autowired
    ThymeleafViewResolver viewResolver;


    /**
     * 更新：页面缓存（Redis）
     * 页面缓存后测试, QPS: 2244/sec
     * @param request Request请求
     * @param response Response响应
     * @param model Model数据
     * @param user 用户
     * @return 静态化页面
     */
    @RequestMapping(path = "/to_list", produces = "text/html")
    @ResponseBody
    public String list(HttpServletRequest request, HttpServletResponse response, Model model, FlashSaleUser user) {
        /*---------------------------去缓存---------------------------*/
        // 1.取缓存
        String goodsListHtml = redisService.get(GoodsKey.getGoodsList, "wx", String.class);
        if (!StringUtils.isEmpty(goodsListHtml)) {
            log.debug("/to_list ==> 使用的是Redis中的缓存");
            return goodsListHtml;
        }
        /*---------------------------手动渲染---------------------------*/
        // 2. 从 [mysql数据库] 中, 查询商品列表
        List<GoodsVo> goodsList = goodsService.listGoodsVo();

        // 3.Model中放入[用户, 商品]信息
        model.addAttribute("user", user);
        model.addAttribute("goodsList", goodsList);

        // 4.手动渲染模板
        // 细节: 提供model参数才能渲染上对应的动态页面
        WebContext webContext = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());
        goodsListHtml = viewResolver.getTemplateEngine().process("goods_list", webContext);

        /*---------------------------结果输出---------------------------*/
        // 5.存入Redis
        if (!StringUtils.isEmpty(goodsListHtml)) {
            redisService.set(GoodsKey.getGoodsList, "wx", goodsListHtml);
        }

        log.debug("/to_list ==> 初次渲染, 查询了一次数据库");
        return goodsListHtml;
    }
```

### 4.2 页面静态化

> 不使用模板引擎, `goods_detail.html`放进static文件, 通过AJAX异步请求, 获取页面所需的个性化数据
>
> 问题:
>
> 1. 服务器时间与客户算时间问题

```java
/**
 *  页面静态化, 异步请求页面的动态数据
 * @param user 根据分布式Session获取页面的动态数据
 * @param goodsId 物品ID号
 * @return 返回动态数据的json数据
 */
@RequestMapping("/detail/{goodsId}")
@ResponseBody
public Result<GoodsDetailVo> detail(FlashSaleUser user, @PathVariable("goodsId") long goodsId) {
    // 0.日志记录
    log.trace("商品列表页 : 页面静态化, 异步请求页面的动态数据");
    // 1.获取秒杀商品信息
    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
    // 2.计算秒杀信息
    long startTime = goods.getStartDate().getTime(),
            endTime = goods.getEndDate().getTime(),
            curTime = System.currentTimeMillis();
    log.debug("物品" + goodsId + "秒杀开始时间 : " + goods.getStartDate().toString());
    log.debug("物品" + goodsId + "秒杀结束时间 : " + goods.getEndDate().toString());
    int flashSaleStatus = 0, remainSeconds = 0;
    if (curTime < startTime) {//秒杀还没开始，倒计时
        remainSeconds = (int) ((startTime - curTime) / 1000);
        log.debug("秒杀未开始, 剩余时间为 : " + remainSeconds + " 秒");
    } else if (curTime > endTime) {//秒杀已经结束
        log.debug("秒杀结束");
        flashSaleStatus = 2;
        remainSeconds = -1;
    } else {//秒杀进行中
        log.debug("秒杀进行中..");
        flashSaleStatus = 1;
    }
    // 3.绑定数据
    GoodsDetailVo vo = new GoodsDetailVo();
    vo.setGoods(goods);
    vo.setUser(user);
    vo.setFlashSaleStatus(flashSaleStatus);
    vo.setRemainSeconds(remainSeconds);
    return Result.success(vo);
}
```

获取的信息`GoodsDetailVo`

```java
@Setter
@Getter
public class GoodsDetailVo {

    private int flashSaleStatus;

    private int remainSeconds;
	// 商品信息和秒杀特殊信息
    private GoodsVo goods;

    private FlashSaleUser user;

}
```

## 五 图片验证码 隐藏秒杀接口

### 5.1 图片验证码

> 图片验证码作用：
>
> 1. 在一定程度上实现削峰，减缓服务器的压力。
> 2. 防止恶意刷接口（区分人机）
>
> 图片验证码的实现：
>
> 1. 使用`BufferedImage`来实现
> 2. 图片校验存入Redis缓存中
>    - 键：`FlashSaleKey.getFlashSaleVerifyCode` + 用户id + 商品id
>    - 有效时间60s

```java
 /**
  *  返回图片验证码
  * @param response response响应, 此处使用response传输图片数据流. 有效时间为60秒.
  * @param user 秒杀用户
  * @param goodsId 秒杀商品di
  * @return Result结果封装的信息
  */
 @GetMapping("/verifyCode")
 @ResponseBody
 public Result<String> getFlashSaleVerifyCode(HttpServletResponse response, FlashSaleUser user,
                                              @RequestParam("goodsId") long goodsId) {
     // 1.登录验证, 分布式Session
     if (user == null) {
         return Result.error(CodeMsg.SESSION_ERROR);
     }
     // 2.输出图片验证码, 利用response的输出流
     OutputStream outputStream = null;
     try {
         BufferedImage image = flashSaleService.createVerifyCode(user, goodsId);
         outputStream = response.getOutputStream();
         ImageIO.write(image, "JPEG", outputStream);
         outputStream.flush();
         return Result.success("图片写入成功~");
     } catch (Exception e) {
         log.error("传递图片验证码时出错!", e);
         return Result.error(CodeMsg.FLASH_SALE_FAIL);
     } finally {
         try {
             if (outputStream != null) {
                 outputStream.close();
             }
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
 }
```

> 图片验证码的验证
>
> 步骤：
>
> 1. 从Redis中获取，Redis中为空或者不匹配返回false
> 2. 匹配成功删除原验证码缓存，避免验证码重复使用

### 5.2 隐藏秒杀地址

> 获取秒杀地址步骤：
>
> 1. 验证用户是否登录
> 2. 判断验证码是否合法
> 3. 若验证码合法，获取秒杀地址
>
> 秒杀地址生成方法：
>
>  MD5(uuid + “12345”)，防止别人找到规律，伪造秒杀地址
>
> **问题：接口防刷算法**

```java
@AccessLimit(seconds = 60, maxCount = 20, needLogin = true)
@GetMapping("/path")
@ResponseBody
public Result<String> getFlashSalePath(HttpServletRequest request, FlashSaleUser user,
                                       @RequestParam("goodsId") long goodsId,
                                       @RequestParam("inputVerifyCode") Integer inputVerifyCode) {
    // 1.登录验证, 分布式Session
    if (user == null) {
        return Result.error(CodeMsg.SESSION_ERROR);
    }
    // 2.判断验证码是否合法
    if (!flashSaleService.checkVerifyCode(user, goodsId, inputVerifyCode)) {
        log.warn("验证码输入错误!");
        return Result.error(CodeMsg.REQUEST_ILLEGAL_VERIFY_CODE);
    }
    // 3.获取秒杀路径
    String fsPath = flashSaleService.createFlashSalePath(user, goodsId);
    return Result.success(fsPath);
}
```

## 六、秒杀流程

### 6.1 秒杀前半段流程

> **秒杀流程：**
>
> 1. bean初始化，把秒杀商品库存加载到Redis中, Redis中超卖标记设置为false FlashSaleKey.isGoodsOver+用户id
> 2. 判断用户是否登录
> 3. 验证秒杀地址Path
> 4. 判断用户是否已经秒杀到
> 5. Redis预减库存
> 6. 秒杀（用户信息， 商品id入队）

bean初始化时

> 类实现了该接口`public class FlashSaleController implements InitializingBean`

```java
/**
 * 系统初始化
 * @throws Exception
 */
@Override
public void afterPropertiesSet() throws Exception {
    List<GoodsVo> goodsList = goodsService.listGoodsVo();
    if (goodsList == null) {
        return;
    }
    for (GoodsVo goods : goodsList) {
        redisService.set(GoodsKey.getFlashSaleGoodsStock, "" + goods.getId(), goods.getStockCount());
        localOverMap.put(goods.getId(), false);
    }
}
```

> **秒杀前半段逻辑**

```java
/**
 *  秒杀接口
 *
 *  秒杀接口测试记录:
 *  - 第 5 章 2054 /sec
 *  - 第 6 章 4502 /sec
 *  - 第 6 章 电脑关闭其他软件 6453 /sec
 * @param user 秒杀用户
 * @param goodsId 货物Id
 * @return  秒杀信息
 */
@PostMapping("/{inputFSPath}/do_sell")
@ResponseBody
public Result<Integer> list(FlashSaleUser user, @RequestParam("goodsId") long goodsId,
                            @PathVariable("inputFSPath") String inputFSPath) {
    // 1.判断用户是否登录
    if (user == null) {
        return Result.error(CodeMsg.SESSION_ERROR);
    }
    // 2.验证Path
    if (!flashSaleService.checkPath(user, goodsId, inputFSPath)) {
        log.warn("用户秒杀请求路径不合法!");
        return Result.error(CodeMsg.REQUEST_ILLEGAL);
    }
    // 3.内存标记, 减少Redis访问
    boolean over = localOverMap.get(goodsId);
    if (over) {
        log.trace("根据over判断已经卖完~");
        return Result.error(CodeMsg.FLASH_SALE_OVER);
    }
    // 4.判断是否已经秒杀到
    FlashSaleOrder fsOrder = orderService.getFlashSaleOrderByUserIdGoodsId(user.getId(), goodsId);
    if (fsOrder != null) {
        log.trace("入队前, 通过访问redis缓存判断已经秒杀到物品" + goodsId);
        return Result.error(CodeMsg.REPEAT_FLASH_SALE);
    }
    // 5.Redis 预减库存
    Long stock = redisService.decr(GoodsKey.getFlashSaleGoodsStock, "" + goodsId);
    log.trace("Redis预减库存, 物品" + goodsId + "剩余数量为 : " + stock);
    if (stock < 0) {
        localOverMap.put(goodsId, true);
        return Result.error(CodeMsg.FLASH_SALE_OVER);
    }
    // 5.入队
    FlashSaleMessage flashSaleMessage = new FlashSaleMessage();
    flashSaleMessage.setUser(user);
    flashSaleMessage.setGoodsId(goodsId);
    mqSender.sendFlashSaleMessage(flashSaleMessage);
    log.trace("秒杀信息入队," + flashSaleMessage);
    return Result.success(0);   // 排队中
}
```

### 6.2 秒杀后半段流程

> **秒杀后半段流程：**
>
> 1. 从队列中获取消息
> 2. 查看库存，判断是否已经秒杀 (数据库中)
> 3. 判断是否已经秒杀到(Redis中查询订单)
> 4. 减库存，下订单，写入秒杀订单

```java
@RabbitListener(queues = MQConfig.FLASH_SALE_QUEUE)
public void receiveFlashSaleMsg(String message) {
    // 1.从队列中获取信息
    log.trace("MQReceive => receive  message:" + message);
    FlashSaleMessage fsMsg = RedisService.stringToBean(message, FlashSaleMessage.class);
    FlashSaleUser user = fsMsg.getUser();
    long goodsId = fsMsg.getGoodsId();
    // 2.查看库存, 判断是否进行秒杀
    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
    if (goods.getStockCount() <= 0) {
        log.debug("出队后, 判断秒杀商品" + goodsId + "为0, 已经秒杀完毕");
        return;
    }
    // 3.判断是否已经秒杀到
    FlashSaleOrder order = orderService.getFlashSaleOrderByUserIdGoodsId(user.getId(), goodsId);
    if (order != null) {
        log.debug("出队后, 判断用户" +user.getId() + "已经秒杀到商品" + goodsId);
        return;
    }
    // 4.减库存, 下订单, 写入秒杀订单
    flashSaleService.flashSale(user, goods);
}
```

> **减库存下订单事务：**
>
> 1. 减库存判断是否成功
>
>    > 保证$stock > 0$，才能减库存
>
>    ```sql
>    update flash_sale_goods set stock_count = stock_count - 1 where goods_Id = #{goodsId} and stock_count > 0
>    ```
>
> 2. 如果减库存成功
>
>    1. 生成订单
>
> 3. 如果减库存失败
>
>    1. 设置Redis键值标记位，`FlashSaleKey.isGoodsOver` + id =》 该商品已经卖完

```java
 @Transactional
 public OrderInfo flashSale(FlashSaleUser user, GoodsVo goods) {
     // 减库存, 下订单, 写入秒杀订单
     if (goodsService.reduceStock(goods)) {
         log.info("用户" + user.getId() + "秒杀到商品" + goods.getId());
         return orderService.createOrder(user, goods);
     } else {
         log.warn("商品已经秒杀完毕, 用户" + user.getId() + "秒杀失败!");
         setGoodsOver(goods.getId());
         return null;
         // throw new GlobalException(CodeMsg.FLASH_SALE_OVER);
     }
 }
```

> **生成订单：**
>
> 1. 根据用户信息和商品信息生成订单对象`OrderInfo orderInfo`
> 2. 存入数据库，主键自增，并自动存入对象属性中
> 3. 根据订单信息生成秒杀订单`FlashSaleOrder fsOrder`
> 4. 存入数据库，存入Redis（`OrderKey.getFlashSaleOrderKey` + 用户id + 货物id）



```java
@Transactional
public OrderInfo createOrder(FlashSaleUser fsUser, GoodsVo goods) {
    // 1.生成订单, 填入信息
    OrderInfo orderInfo = new OrderInfo();
    orderInfo.setUserId(fsUser.getId());
    orderInfo.setGoodsId(goods.getId());
    orderInfo.setGoodsName(goods.getGoodsName());
    orderInfo.setGoodsCount(1);
    orderInfo.setGoodsPrice(goods.getFlashSalePrice());
    orderInfo.setStatus(0);
    orderInfo.setCreateDate(new Date());
    orderInfo.setDeliveryAddrId(0L);
    orderInfo.setOrderChannel(1);
    // 2.存入数据库
    // [id自增赋值到哪里? => orderInfo.id中]
    orderDao.insert(orderInfo);
    // 3.生成秒杀订单, 并存入数据库
    FlashSaleOrder fsOrder = new FlashSaleOrder();
    fsOrder.setUserId(fsUser.getId());
    fsOrder.setOrderId(orderInfo.getId());
    fsOrder.setGoodsId(goods.getId());
    orderDao.insertFlashSaleOrder(fsOrder);
    redisService.set(OrderKey.getFlashSaleOrderKey, "" + fsUser.getId() + "_" + goods.getId(), fsOrder);
    return orderInfo;
}
```

### 6.3 客户端获取秒杀结果

> 客户端，轮询查询秒杀结果
>
> 1. `result > 0`， 秒杀成功返回秒杀订单id，进一步可查看订单
> 2. `result == 0`，未查到，秒杀也未进行完，继续轮询
> 3. `result < 0`，秒杀失败

```java
function getFlashSaleResult(goodsId) {
    g_showLoading();
    $.ajax({
        url: "./sell/result",
        type: "GET",
        data: {
            goodsId: $("#goodsId").val(),
        },
        success: function (data) {
            if (data.code == 0) {
                var result = data.data;
                if (result < 0) {
                    layer.msg("对不起，秒杀失败");
                } else if (result == 0) {//继续轮询
                    setTimeout(function () {
                        getFlashSaleResult(goodsId);
                    }, 200);
                } else {
                    layer.confirm("恭喜你，秒杀成功！查看订单？", {btn: ["确定", "取消"]},
                        function () {
                            window.location.href = "./order_detail.htm?orderId=" + result;
                        },
                        function () {
                            layer.closeAll();
                        });
                }
            } else {
                layer.msg(data.msg);
            }
        },
        error: function () {
            layer.msg("客户端请求有误");
        }
    });
}
```

**服务器端：**

```java
 /**
  *  查询订单情况
  * @param user 查询用户
  * @param goodsId 查询的秒杀商品
  * @return result = 0 等待, 下一次轮询
  *                = -1 秒杀事变
  *                > 0 订单id
  */
 @GetMapping("/result")
 @ResponseBody
 public Result<Long> flashSaleResult(FlashSaleUser user, @RequestParam("goodsId") long goodsId) {
     // 0.用户登陆验证
     if (user == null) {
         return Result.error(CodeMsg.SESSION_ERROR);
     }
     long result = flashSaleService.getFlashSaleResult(user.getId(), goodsId);
     return Result.success(result);
 }

public long getFlashSaleResult(long userId, long goodsId) {
    // 1.获取秒杀订单
    FlashSaleOrder fsOrder = orderService.getFlashSaleOrderByUserIdGoodsId(userId, goodsId);
    // 2.判断秒杀情况
    // a.秒杀成功
    if (fsOrder != null) {
        return fsOrder.getOrderId();
    } else {
        // b.秒杀失败
        if (getGoodsOver(goodsId)) {
            return -1;
        } else {
            // c.等待结果
            return 0;
        }
    }
}
```

## 七、秒杀问题

### 7.1 秒杀流程，如何保证数据库安全



### 7.2 如何解决超卖问题

1. 数据库采用尝试扣减库存，扣减库存成功才会进行下单。
2. 把库存数据放入到缓存中，利用缓存的原子特性保证同时只有一个线程操作库存

### 7.3 如果没有完成支付，怎么处理流程

1. 

### 7.4 数据库和Redis如何实现一致性（redis -》 10个，Mysql5个）

1. 中间件的方式
2. 

### 7.5 小米和京东的秒杀系统



### 7.6 能否实时展示当前数量在前端



### 7.7 视频总结

#### 7.7.1 问题挑战

流量大 固定时间 库存小 不能超卖 不能少买 限购 黄牛  

1. 什么时候把库存写入到Redis中

   秒杀活动创建/维护时写入Redis

2. 如何保证活动数据库和库存数据库一致？ 

   1. 活动表 ----- 售卖数量 static
   2. 库存表 ----- 库存数量 dynamic
   3. Redis ------- 库存数量 dynamic

   使用分布式事务 Seata

   > 分布式事务 是为了保证多个数据库的操作同时成功或者同时失败才需要用到的，对强一致性有要求的业务场景可以考虑使用分布式事务，如银行转账就需要强一致性。

   使用消息队列

3.  秒杀倒计时如何实现 

   前端页面第一次从服务端获取活动开始时间、服务端当前时间，然后在客户端计算倒计时，最后提交订单时，服务端再次校验客户端和服务端当前时间

4. 下单减库存/支付减库存，which one?

   下单锁定库存，支付减库存

5. 如何防止商品被超卖

   把库存数据放入到缓存中，利用缓存的原子特性保证同时只有一个线程操作库存

6. 库存写回数据库的时机？

   定时任务同步Redis的数据写回数据库。

7.  小流量到大流量的转变

   1. 服务的调用频次高了
   2. 数据库的读写频次高了
   3. 页面刷新的频次高了
   4. 非法请求的数量多了

8. 双11刷爆页面，哪个方法比较优雅？

   把页面做静态化处理，页面放在静态服务器（CDN，Content delivery network ）上

9. 大量的爬虫请求或者黄牛请求，如何解决？

   - 增加页面访问验证码
   - 增加IP黑名单

10. 秒杀服务器挂了，如何不影响正常商品购买？

    - 采用熔断的方式 Hystrix Sentinel

11. 短时间内频繁调用接口下单，怎么办？

    - 采用限流器（Rate Limiter）

12. 非购物关键路径服务降级

    - 查看评论
    - 每一页的评论数/历史订单数

13. d

### 7.8 博文

> https://www.jianshu.com/p/df4fbecb1a4b

#### 7.8.1 同一个账号，一次发送多个请求

> 存在逻辑被绕过的风险，导致少买问题

在程序入口处，一个账号只允许接受1个请求，其他请求过滤。不仅解决了同一个账号，发送N个请求的问题，还保证了后续的逻辑流程的安全。**实现方案，可以通过Redis这种内存缓存服务，写入一个标志位（只允许1个请求写成功，结合watch的乐观锁的特性），成功写入的则可以继续参加**。

![img](https://upload-images.jianshu.io/upload_images/2062729-e4ee2533cc911ae6.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

或者，自己实现一个服务，将同一个账号的请求放入一个队列中，处理完一个，再处理下一个。

#### 7.8.2 多个账号，一次性发送多个请求

**应对方案：**

这种场景，可以**通过检测指定机器IP请求频率就可以解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求**：

> 1. **弹出验证码，最核心的追求，就是分辨出真实用户。**因此，大家可能经常发现，网站弹出的验证码，有些是“鬼神乱舞”的样子，有时让我们根本无法看清。他们这样做的原因，其实也是为了让验证码的图片不被轻易识别，因为强大的“自动脚本”可以通过图片识别里面的字符，然后让脚本自动填写验证码。实际上，有一些非常创新的验证码，效果会比较好，例如给你一个简单问题让你回答，或者让你完成某些简单操作（例如百度贴吧的验证码）。
> 2. **直接禁止IP，实际上是有些粗暴的，因为有些真实用户的网络场景恰好是同一出口IP的，可能会有“误伤“**。但是这一个做法简单高效，根据实际场景使用可以获得很好的效果。

#### 7.8.3 多个账号，不同IP发送不同请求

**应对方案：**

> 说实话，这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易“误伤“真实用户，这个时候，**通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们**。
>
> 僵尸账号也还是有一些共同特征的，例如**账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等**。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。**通过这些业务手段，也是可以过滤掉一些僵尸号**。































































